---
title: "Plugin Hooks"
seo:
  title: "Vulcn Plugin Hooks — Lifecycle Events for Security Testing Plugins"
  description: "Complete reference for all Vulcn plugin hooks: initialization, recording, running, browser events, and report generation."
description: "Available hooks for Vulcn plugins"
---

## Hook Categories

Vulcn provides hooks for different lifecycle phases:

| Category           | Hooks                                                                          | When Called                        |
| ------------------ | ------------------------------------------------------------------------------ | ---------------------------------- |
| **Initialization** | `onInit`, `onDestroy`                                                          | Plugin setup/teardown              |
| **Recording**      | `onRecordStart`, `onRecordStep`, `onRecordEnd`                                 | During session recording           |
| **Scanning**       | `onScanStart`, `onScanEnd`                                                     | Once per scan (wraps all sessions) |
| **Running**        | `onRunStart`, `onBeforePayload`, `onAfterPayload`, `onBeforeClose`, `onRunEnd` | Per session execution              |
| **Browser Events** | `onDialog`, `onConsoleMessage`, `onPageLoad`                                   | Browser activity                   |

## Initialization Hooks

### onInit

Called when the plugin is initialized.

```typescript
onInit?: (ctx: PluginContext) => Promise<void>;
```

**Use cases:**

- Load configuration
- Set up resources
- Register payloads

### onDestroy

Called when the plugin is destroyed.

```typescript
onDestroy?: (ctx: PluginContext) => Promise<void>;
```

**Use cases:**

- Clean up resources
- Save state
- Close connections

## Recording Hooks

### onRecordStart

Called when recording begins.

```typescript
onRecordStart?: (ctx: RecordContext) => Promise<void>;
```

**Context includes:**

- `startUrl` - Initial URL
- `browser` - Browser type
- `page` - Playwright page object

### onRecordStep

Called after each step is recorded. Can modify or filter steps.

```typescript
onRecordStep?: (step: Step, ctx: RecordContext) => Promise<Step | null>;
```

**Return value:**

- `Step` - Modified step to record
- `null` - Skip this step

**Example:**

```typescript
onRecordStep: async (step, ctx) => {
  // Skip external navigation
  if (step.type === "navigate" && !step.url.includes("example.com")) {
    return null;
  }
  return step;
};
```

### onRecordEnd

Called when recording ends. Can modify the final session.

```typescript
onRecordEnd?: (session: Session, ctx: RecordContext) => Promise<Session>;
```

## Scan-Level Hooks

Scan-level hooks fire **once per scan**, wrapping all session executions. They are called by `executeScan()` when running multiple sessions with a shared browser.

### onScanStart

Called once before any session is executed.

```typescript
onScanStart?: (ctx: ScanContext) => Promise<void>;
```

**Context includes:**

- `sessions` — All sessions in this scan
- `sessionCount` — Total number of sessions
- `headless` — Whether running headless

**Use cases:**

- Initialize scan-wide state (e.g., shared metrics, timers)
- Log scan scope for auditing
- Set up external integrations (e.g., Jira tickets, Slack notifications)

**Example:**

```typescript
onScanStart: async (ctx) => {
  ctx.logger.info(`Starting scan of ${ctx.sessionCount} sessions`);
  ctx.logger.info(`Sessions: ${ctx.sessions.map((s) => s.name).join(", ")}`);
};
```

### onScanEnd

Called once after all sessions have executed. Can transform the aggregate result.

```typescript
onScanEnd?: (result: RunResult, ctx: ScanContext) => Promise<RunResult>;
```

**Use cases:**

- Generate scan-wide aggregated reports
- Deduplicate findings across sessions
- Send summary to external services
- Calculate aggregate risk scores

**Example — Deduplicate findings:**

```typescript
onScanEnd: async (result, ctx) => {
  const seen = new Set<string>();
  const deduped = result.findings.filter((f) => {
    const key = `${f.type}:${f.url}:${f.payload}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });

  ctx.logger.info(
    `Deduplicated ${result.findings.length} → ${deduped.length} findings`,
  );

  return { ...result, findings: deduped };
};
```

<Tip>
  Scan-level hooks are only called when using `executeScan()` (multi-session
  mode). If you run a single session with `execute()`, only the per-session
  hooks (`onRunStart`/`onRunEnd`) fire.
</Tip>

## Running Hooks

### onRunStart

Called when test execution begins.

```typescript
onRunStart?: (ctx: RunContext) => Promise<void>;
```

**Context includes:**

- `session` - Session being executed
- `page` - Playwright page object
- `headless` - Whether running headless

### onBeforePayload

Called before each payload is injected. Can modify the payload.

```typescript
onBeforePayload?: (
  payload: string,
  step: Step,
  ctx: RunContext
) => Promise<string>;
```

**Example:**

```typescript
onBeforePayload: async (payload, step, ctx) => {
  // Add prefix to all payloads
  return `PREFIX_${payload}`;
};
```

### onAfterPayload

Called after each payload is injected. Can return findings.

```typescript
onAfterPayload?: (ctx: DetectContext) => Promise<Finding[]>;
```

**Context includes:**

- `step` - Current step
- `payloadValue` - Injected payload
- `page` - Current page state

### onRunEnd

Called when test execution completes. Can modify the result. This is the primary hook used by reporter plugins.

```typescript
onRunEnd?: (result: RunResult, ctx: RunContext) => Promise<RunResult>;
```

**Use cases:**

- Generate security reports (HTML, JSON, YAML, SARIF)
- Send results to external services (Slack, Jira, SIEM)
- Aggregate or transform findings
- Calculate risk scores

**Example — Report generation:**

```typescript
onRunEnd: async (result, ctx) => {
  const html = generateHtml({
    session: ctx.session,
    result,
    generatedAt: new Date().toISOString(),
    engineVersion: ctx.engine.version,
  });

  await writeFile("vulcn-report.html", html);
  ctx.logger.info("Report saved to vulcn-report.html");

  return result; // Pass through unmodified
};
```

<Tip>
  The built-in `@vulcn/plugin-report` uses this hook. See the [Report Plugin
  docs](/plugins/plugin-report) for details.
</Tip>

### onBeforeClose

Called before the browser/driver is closed. Plugins should await any pending async work here.

```typescript
onBeforeClose?: (ctx: PluginContext) => Promise<void>;
```

**Use cases:**

- Flush in-flight async response handlers (e.g., passive scanner)
- Save accumulated state before browser teardown
- Clean up page-level event listeners

**Example — Drain pending work:**

```typescript
const pendingHandlers: Promise<void>[] = [];

// In onRunStart:
page.on("response", (response) => {
  const promise = analyzeResponse(response);
  pendingHandlers.push(promise);
});

// In onBeforeClose:
onBeforeClose: async () => {
  await Promise.allSettled(pendingHandlers);
  pendingHandlers.length = 0;
};
```

## Browser Event Hooks

### onDialog

Called when a dialog (alert/confirm/prompt) appears.

```typescript
onDialog?: (dialog: Dialog, ctx: DetectContext) => Promise<Finding | null>;
```

**Dialog properties:**

- `type()` - "alert" | "confirm" | "prompt" | "beforeunload"
- `message()` - Dialog message

**Example:**

```typescript
onDialog: async (dialog, ctx) => {
  if (dialog.type() === "alert") {
    return {
      type: "xss",
      severity: "high",
      title: "XSS: alert() triggered",
      payload: ctx.payloadValue,
      // ...
    };
  }
  return null;
};
```

### onConsoleMessage

Called when console.log/warn/error is called.

```typescript
onConsoleMessage?: (msg: ConsoleMessage, ctx: DetectContext) => Promise<Finding | null>;
```

**Message properties:**

- `text()` - Message text
- `type()` - "log" | "warn" | "error" | etc.

### onPageLoad

Called when a page finishes loading.

```typescript
onPageLoad?: (page: Page, ctx: DetectContext) => Promise<Finding[]>;
```

## Context Types

### PluginContext

Base context available to all hooks:

```typescript
interface PluginContext {
  config: Record<string, unknown>; // Plugin config
  engine: EngineInfo; // Engine version info
  payloads: RuntimePayload[]; // Available payloads
  findings: Finding[]; // Collected findings (read-only view)
  addFinding: (finding: Finding) => void; // Add finding via callback chain
  logger: PluginLogger; // Scoped logger
  fetch: typeof fetch; // Fetch API
}
```

<Warning>
  Always use `ctx.addFinding()` to report findings instead of pushing to
  `ctx.findings` directly. This ensures consumers are notified via the
  `onFinding` callback and findings survive timeouts.
</Warning>

### RecordContext

Extended context for recording hooks:

```typescript
interface RecordContext extends PluginContext {
  startUrl: string;
  browser: BrowserType;
  page: Page;
}
```

### RunContext

Extended context for running hooks:

```typescript
interface RunContext extends PluginContext {
  session: Session;
  page: Page;
  browser: BrowserType;
  headless: boolean;
}
```

### DetectContext

Extended context for detection hooks:

```typescript
interface DetectContext extends RunContext {
  step: Step; // Current step
  payloadSet: RuntimePayload;
  payloadValue: string; // Actual payload
  stepId: string; // Step identifier
}
```

### ScanContext

Extended context for scan-level hooks:

```typescript
interface ScanContext extends PluginContext {
  sessions: Session[]; // All sessions in the scan
  headless: boolean; // Whether running headless
  sessionCount: number; // Total sessions
}
```
