---
title: "Browser Driver"
description: "Record, crawl, and replay web application interactions using Playwright"
---

## Overview

The browser driver (`@vulcn/driver-browser`) enables security testing of web applications by recording and replaying browser interactions. It uses [Playwright](https://playwright.dev) for browser automation.

**Key capabilities:**

- **Record** browser interactions (clicks, form fills, navigation)
- **Crawl** to auto-discover forms and injection points
- **Replay** sessions with security payloads using persistent browser + goBack() cycling
- **Tier 1 HTTP fast scan** — replay captured requests via `fetch()` at ~50ms/payload
- **Authenticated scanning** — login detection, credential storage, session expiry handling

## Installation

```bash
npm install @vulcn/driver-browser
```

<Note>
  The browser driver is included with the `vulcn` CLI by default. You only need
  to install it separately for programmatic usage.
</Note>

## Configuration

| Option     | Type                                  | Default                        | Description                              |
| ---------- | ------------------------------------- | ------------------------------ | ---------------------------------------- |
| `startUrl` | `string`                              | required                       | URL to navigate to when recording starts |
| `browser`  | `"chromium" \| "firefox" \| "webkit"` | `"chromium"`                   | Browser engine to use                    |
| `viewport` | `{ width: number, height: number }`   | `{ width: 1280, height: 720 }` | Browser viewport size                    |
| `headless` | `boolean`                             | `false`                        | Run browser in headless mode             |

### Example Configuration

```yaml
# .vulcn.yml
scan:
  browser: chromium
  headless: true
  timeout: 30000
```

## Step Types

The browser driver defines the following step types:

### `browser.navigate`

Navigate to a URL.

```yaml
- id: step_001
  type: browser.navigate
  url: https://example.com/login
  timestamp: 0
```

### `browser.click`

Click on an element.

```yaml
- id: step_002
  type: browser.click
  selector: button[type="submit"]
  position:
    x: 150
    y: 300
  timestamp: 1000
```

### `browser.input`

Type into a form field. This is the primary injection point for payloads.

```yaml
- id: step_003
  type: browser.input
  selector: input[name="username"]
  value: testuser
  injectable: true # Mark as payload injection point
  timestamp: 1500
```

<Info>
  Set `injectable: true` on input steps to mark them as payload injection
  points. During replay, Vulcn injects security payloads into these fields.
</Info>

### `browser.keypress`

Press a key or key combination.

```yaml
- id: step_004
  type: browser.keypress
  key: Enter
  modifiers:
    - ctrl
  timestamp: 2000
```

### `browser.scroll`

Scroll the page or an element.

```yaml
- id: step_005
  type: browser.scroll
  selector: .scrollable-container # Optional, defaults to window
  position:
    x: 0
    y: 500
  timestamp: 2500
```

### `browser.wait`

Wait for a duration (useful for manual session editing).

```yaml
- id: step_006
  type: browser.wait
  duration: 1000 # milliseconds
  timestamp: 3000
```

## Browser Support

The driver uses a smart fallback strategy:

1. **System Chrome** - Uses your installed Chrome browser (zero download)
2. **System Edge** - Falls back to Microsoft Edge if Chrome isn't found
3. **Playwright Browsers** - Uses Playwright's bundled browsers as last resort

Check available browsers:

```bash
vulcn doctor
```

Install Playwright browsers if needed:

```bash
vulcn install chromium
vulcn install --all
```

## Persistent Browser & Payload Cycling

The browser driver uses a **persistent browser** strategy for speed:

1. **One browser for the entire scan** — instead of launching a new browser per session, a single browser instance is reused across all sessions in a scan
2. **goBack() payload cycling** — after a form submission causes navigation, `goBack()` returns to the form page much faster than a full `page.goto()`, especially for SPAs where the DOM is cached
3. **Interleaved payloads** — round-robin across categories (XSS, SQLi, etc.) ensures at least one payload from each category is tested quickly, so dedup-based early-break fires sooner

This means scanning 100 payloads against a form takes seconds instead of minutes.

<Info>
  The persistent browser is managed automatically by `executeScan()`. When
  running a single session via `execute()`, the driver launches and closes its
  own browser (backward-compatible standalone mode).
</Info>

## Tiered Scanning

The browser driver supports **two scanning tiers**:

### Tier 1: HTTP Fast Scan (~50ms/payload)

During crawl, Vulcn captures HTTP request metadata (`CapturedRequest`) for each discovered form. The HTTP scanner replays these via Node.js `fetch()`:

1. Substitutes payload into the injectable field
2. Sends the HTTP request
3. Checks response body for reflection patterns
4. If reflected → marks finding as `needsBrowserConfirmation`

**What it catches:** Reflected XSS, error-based SQLi, server-side reflection

**What it misses:** DOM-based XSS, client-side state bugs, CSP-blocked attacks

### Tier 2: Browser Replay (~2-5s/payload)

Full Playwright-based replay — navigates to the page, fills the form, submits, and monitors for actual JavaScript execution (dialogs, console markers).

**What it catches:** Everything Tier 1 catches + DOM-based XSS, client-side execution proof

<Tip>
  Tier 1 findings are tagged with `metadata.detectionMethod: "tier1-http"` and
  `metadata.needsBrowserConfirmation: true` so you can distinguish them from
  browser-confirmed findings in reports.
</Tip>

### Programmatic Tier 1 Usage

```typescript
import { httpScan, buildCapturedRequests } from "@vulcn/driver-browser";
import type { CapturedRequest } from "@vulcn/engine";

// Build requests from discovered forms
const requests: CapturedRequest[] = buildCapturedRequests([
  {
    pageUrl: "https://example.com/search",
    action: "/search",
    method: "GET",
    inputs: [{ name: "q", injectable: true, type: "text" }],
    sessionName: "search-form",
  },
]);

// Run HTTP-level scan
const result = await httpScan(requests, payloads, {
  timeout: 10_000,
  concurrency: 10,
  cookies: "session=abc123", // For authenticated scanning
  onProgress: (completed, total) => {
    console.log(`${completed}/${total}`);
  },
});

console.log(`Sent ${result.requestsSent} requests in ${result.duration}ms`);
console.log(`Found ${result.findings.length} reflections`);
console.log(`${result.reflectedRequests.length} need browser confirmation`);
```

## Auto-Crawl

The browser driver supports **auto-crawl** — an automated mode that discovers forms, inputs, and injection points without manual recording.

### How it Works

1. Opens a headless browser and navigates to the target URL
2. Discovers all `<form>` elements and standalone inputs on the page
3. Identifies injectable text-like inputs (text, search, url, email, tel, password, textarea)
4. Finds submit triggers (submit buttons, untyped buttons, or falls back to Enter keypress)
5. Follows same-origin links with configurable depth (BFS traversal)
6. Generates a `Session` per discovered form with `navigate → input → submit` steps
7. Captures `CapturedRequest` metadata for each form (for Tier 1 HTTP scanning)

### Configuration

| Option        | Type      | Default | Description                                        |
| ------------- | --------- | ------- | -------------------------------------------------- |
| `maxDepth`    | `number`  | `2`     | Maximum link-following depth (0 = target URL only) |
| `maxPages`    | `number`  | `20`    | Maximum number of pages to crawl                   |
| `pageTimeout` | `number`  | `10000` | Page load timeout in milliseconds                  |
| `sameOrigin`  | `boolean` | `true`  | Only follow links to the same origin               |

### CLI Usage

```bash
# Auto-crawl instead of manual recording
vulcn record https://example.com --auto

# With depth control
vulcn record https://example.com --auto --depth 3 --max-pages 50
```

### Programmatic Usage

```typescript
import { DriverManager } from "@vulcn/engine";
import browserDriver from "@vulcn/driver-browser";

const manager = new DriverManager();
manager.register(browserDriver);

// Auto-discover forms
const sessions = await manager.crawl(
  "browser",
  {
    startUrl: "https://example.com",
    browser: "chromium",
    headless: true,
  },
  {
    maxDepth: 2,
    maxPages: 20,
  },
);

console.log(`Found ${sessions.length} injectable forms`);

// Execute all sessions with payloads
const result = await manager.executeScan(sessions, pluginManager, {
  headless: true,
});
console.log(`Found ${result.aggregate.findings.length} findings`);
```

### Direct Access (with CapturedRequests)

Use the crawler directly to get both sessions and HTTP request metadata:

```typescript
import { crawlAndBuildSessions } from "@vulcn/driver-browser";

const { sessions, capturedRequests } = await crawlAndBuildSessions(
  { startUrl: "https://example.com", headless: true },
  { maxDepth: 1, maxPages: 5 },
);

console.log(
  `${sessions.length} sessions, ${capturedRequests.length} HTTP requests`,
);
```

<Note>
  `crawlAndBuildSessions()` returns a `CrawlResult` with both `sessions` (for
  Tier 2 browser replay) and `capturedRequests` (for Tier 1 HTTP scanning).
</Note>

## Authentication

The browser driver includes a full authentication system:

### Login Form Auto-Detection

```typescript
import { detectLoginForm, performLogin } from "@vulcn/driver-browser";

// Auto-detect login form on a page
const loginForm = await detectLoginForm(page);
// Returns: { usernameSelector, passwordSelector, submitSelector, formSelector }

// Perform login with detected form
const result = await performLogin(page, {
  username: "admin",
  password: "password",
  loginForm,
});
// Returns: { success, storageState }
```

### Session Expiry Detection

```typescript
import { checkSessionAlive } from "@vulcn/driver-browser";

const alive = await checkSessionAlive(page, {
  loggedInIndicator: "Welcome",
  loggedOutIndicator: "Login",
  sessionExpiry: {
    statusCodes: [401, 403],
    redirectPattern: "/login",
  },
});

if (!alive) {
  // Re-authenticate...
}
```

### CLI Workflow

```bash
# 1. Store credentials (AES-256-GCM encrypted)
vulcn store admin password --login-url http://localhost:8080/login.php

# 2. Crawl with authentication (auth auto-discovered from auth/state.enc)
vulcn crawl

# 3. Scan with authentication (auth auto-discovered)
vulcn run -p xss -r html
```

## Programmatic Usage

### Recording

```typescript
import browserDriver from "@vulcn/driver-browser";

// Start recording
const handle = await browserDriver.recorder.start(
  {
    startUrl: "https://example.com",
    browser: "chromium",
    headless: false,
  },
  {},
);

// Wait for user interaction...

// Stop and get session
const session = await handle.stop();
console.log(session.steps);
```

### Running

```typescript
import {
  DriverManager,
  PluginManager,
  parseProjectConfig,
} from "@vulcn/engine";
import browserDriver from "@vulcn/driver-browser";

// Register driver and load config
const drivers = new DriverManager();
drivers.register(browserDriver);

const manager = new PluginManager();
const config = parseProjectConfig({ payloads: { types: ["xss"] } });
await manager.loadFromConfig(config);

// Execute scan
const result = await drivers.executeScan([session], manager, {
  headless: true,
  onFinding: (finding) => console.log("Found:", finding.title),
});

console.log(`Found ${result.aggregate.findings.length} vulnerabilities`);
```

## Detection

During replay, the browser driver monitors for:

- **JavaScript Dialogs** - `alert()`, `confirm()`, `prompt()` triggered by payloads
- **Console Messages** - `console.log()` outputs matching payload markers
- **Payload Reflection** - Payload strings appearing in page content (Tier 2)
- **HTTP Reflection** - Payload patterns in HTTP response bodies (Tier 1)

These detections are enhanced when combined with detection plugins configured in `.vulcn.yml`:

```yaml
# .vulcn.yml
detection:
  xss:
    dialogs: true
    console: true
  reflection:
    enabled: true
```

## Session Format

Sessions are YAML files with a `driver:` field:

```yaml
name: Login Form Test
driver: browser
driverConfig:
  browser: chromium
  startUrl: https://vulnerable-app.example.com/login
steps:
  - id: step_001
    type: browser.navigate
    url: https://vulnerable-app.example.com/login

  - id: step_002
    type: browser.input
    selector: "#username"
    value: admin
    injectable: true

  - id: step_003
    type: browser.click
    selector: button[type="submit"]
```

Sessions are stored in `sessions/` and auto-discovered by `vulcn run`.

<Card title="Plugin System" icon="plug" href="/plugins/overview">
  Learn how to add detection plugins for comprehensive vulnerability scanning
</Card>
